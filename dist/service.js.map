{"version":3,"sources":["../src/service.js"],"names":["invertObjectKV","isDefined","metricsMessage","Root","fromJSON","lookupType","fsMetrics","$window","window","$timeout","setTimeout","XMLHttpRequest","globalTags","timingRanges","codeRevision","stringReplace","blackList","whiteList","timelinePrefix","loadFired","resetQueue","buildServerSharedDictionary","trackUnsupportedFeatures","upgradeQueue","trackExistingPerformanceEntries","performanceTimeline","performance","getEntries","forEach","entryType","performanceTiming","config","timeParse","clearMeasures","clearResourceTimings","navigationTiming","increment","mark","measure","metricNames","metricTags","eventTypes","Array","isArray","prototype","push","convertWindowQueue","bind","queueMetric","dest","timing","domContentLoadedEventStart","navigationStart","queue","activeBuffer","clearTimeout","reduce","replace","JSON","stringify","encodeTagsIntoMetricName","console","error","from","metric","once","oneTimeMetrics","now","measureSafe","histogram","test","name","initiatorType","licenceUrls","includes","trackLicenseReq","duration","url","cached","decodedBodySize","transferSize","split","pop","parse","enabled","navigator","doNotTrack","isFinite","type","key","val","tags","flushMetrics","bufTime","normalizeTag","id","encodeTags","encodeStat","buildDict","map","slice","Object","defineProperty","value","writable","configurable","enumerable","encodeMetric","aMetric","tag","metricName","stringDict","log","verify","encode","create","finish","open","setRequestHeader","preparePayload","send"],"mappings":"+1CAKA,QAASA,eAAT,GAA+B,CAC7B,GAAM,KAAN,CACA,IAAK,GAAI,EAAT,MACE,EAAQ,IAAR,IAEF,QACD,CAmBD,QAASC,UAAT,GAA2B,CACzB,MAAwB,WAAjB,UACR,CAED,GAAIC,gBAAiB,gBAASC,IAAT,CAAcC,QAAd,oBAA+CC,UAA/C,CAA0D,4BAA1D,CAArB,CAOqBC,SAPrB,YAQE,YAYE,qEAXAC,OAWA,cAXUC,MAWV,OAVAC,QAUA,cAVWD,OAAOE,UAUlB,OATAC,cASA,cATiBH,OAAOG,cASxB,OARAC,UAQA,KAPAC,YAOA,KANAC,YAMA,KALAC,aAKA,KAJAC,SAIA,KAHAC,SAGA,KAFAC,cAEA,yBACA,KAAKX,OAAL,EADA,CAEA,KAAKE,QAAL,EAFA,CAGA,KAAKE,cAAL,EAHA,CAKA,KAAKC,UAAL,CAAkB,KALlB,CAMA,KAAKC,YAAL,EANA,CAOA,KAAKC,YAAL,EAPA,CAQA,KAAKC,aAAL,EARA,CASA,KAAKC,SAAL,EATA,CAUA,KAAKC,SAAL,EAVA,CAWA,KAAKC,cAAL,EAXA,CAaA,KAAKC,SAAL,GAbA,CAeA,KAAKC,UAAL,EAfA,CAgBA,KAAKC,2BAAL,EAhBA,CAkBA,KAAKC,wBAAL,EAlBA,CAoBA,KAAKC,YAAL,EApBA,CAqBA,KAAKC,+BAAL,EACD,CA1CH,8GA4CqC,YAC5B,kCAAiBC,mBADW,GAIjC,KAAKlB,OAAL,CAAamB,WAAb,CAAyBC,UAAzB,GAAsCC,OAAtC,CAA8C,WAAS,EAC7B,SAApB,KAAMC,SAAN,EAAqD,UAApB,KAAMA,SADU,GAEnD,EAAKC,iBAAL,GAEH,CAJD,CAJiC,CASP,MAA1B,QAAKC,MAAL,CAAYC,SAAZ,EAAoC,KAAKzB,OAAL,CAAamB,WAAb,CAAyBO,aAAzB,EATH,CAUjC,kCAAiBC,oBAAjB,EAAyC,KAAK3B,OAAL,CAAamB,WAAb,CAAyBQ,oBAAzB,EAVR,CAWlC,CAvDH,2EAyD8B,CACrB,kCAAiBC,gBADI,EAExB,KAAKC,SAAL,CAAe,mBAAf,CAFwB,CAKrB,kCAAiBC,IALI,EAMxB,KAAKD,SAAL,CAAe,iBAAf,CANwB,CASrB,kCAAiBE,OATI,EAUxB,KAAKF,SAAL,CAAe,iBAAf,CAVwB,CAarB,kCAAiBX,mBAbI,EAcxB,KAAKW,SAAL,CAAe,2BAAf,CAEH,CAzEH,sFA2EoE,YAChE,KAAKG,WAAL,GADgE,CAEhE,KAAKC,UAAL,GAFgE,CAGhE,KAAKC,UAAL,GAHgE,IAM9D,KAAKV,MAAL,CAAYQ,WAAZ,CAAwBX,OAAxB,CAAgC,oBAAU,GAAKW,WAAL,KAAV,CAAhC,CAN8D,IAS9D,KAAKR,MAAL,CAAYS,UAAZ,CAAuBZ,OAAvB,CAA+B,oBAAU,GAAKY,UAAL,IAAqB,IAA/B,CAA/B,CAT8D,IAY9D,KAAKT,MAAL,CAAYU,UAAZ,CAAuBb,OAAvB,CAA+B,oBAAU,GAAKa,UAAL,KAAV,CAA/B,CAEH,CAzFH,mDAgGkB,CACV,KAAKlC,OAAL,CAAaD,SAAb,EACFoC,MAAMC,OAAN,CAAc,KAAKpC,OAAL,CAAaD,SAA3B,CADE,EAEFoC,MAAME,SAAN,CAAgBC,IAAhB,GAAyB,KAAKtC,OAAL,CAAaD,SAAb,CAAuBuC,IAHpC,GAIZ,KAAKtC,OAAL,CAAaD,SAAb,CAAuBuC,IAAvB,CAA8B,KAAKC,kBAAL,CAAwBC,IAAxB,CAA6B,IAA7B,CAJlB,CAKZ,KAAKxC,OAAL,CAAaD,SAAb,CAAuBsB,OAAvB,CAA+B,KAAKrB,OAAL,CAAaD,SAAb,CAAuBuC,IAAtD,CALY,CAOf,CAvGH,gEAyGyE,6DAAjC,CAAiC,mCACrE,GAAa,UAAT,IAAJ,CAasB,QAAhB,UAbN,GAcI,EAAO,KAAKJ,UAAL,GAdX,EAiBE,KAAKO,WAAL,uBAjBF,KAEE,IADA,EAAKC,IAAL,EACA,CAAI,kCAAiBd,gBAArB,CAAuC,CACrC,GAAI,GAAY3B,OAAOkB,WAAP,CAAmBwB,MAAnB,CAA0BC,0BAA1B,CAAuD3C,OAAOkB,WAAP,CAAmBwB,MAAnB,CAA0BE,eAAjG,CACI,OAFiC,CAGnC,KAAKF,MAAL,CAAY,kBAAZ,QAHmC,CAKnC,KAAKd,SAAL,CAAe,eAAf,MAEH,CAPD,IAQE,MAAKA,SAAL,CAAe,mBAAf,MASL,CA7HH,+CA+HgB,CACZ,KAAKiB,KAAL,GADY,CAER,KAAKC,YAFG,EAGV,KAAK/C,OAAL,CAAagD,YAAb,CAA0B,KAAKD,YAA/B,CAHU,CAKZ,KAAKA,YAAL,GACD,CArIH,oDAuIqB,CAGjB,MAFA,IAAO,EAEP,CAAO,KAAKvC,aAAL,CAAmByC,MAAnB,CAA0B,4DAA4B,GAAIC,OAAJ,KAA5B,CAA1B,GACR,CA3IH,+CA8IwB,4EACpB,MAAO,GAAMD,MAAN,CAAa,aAAc,WAG9B,GAAQ,EAHsB,CAIvB,EAAK,EACXC,OADW,CACH,YADG,CACW,GADX,CAJkB,EAMrB,GAAQxD,UAAU,EAAKsC,WAAL,GAAV,CANa,CAOvB,EAAKA,WAAL,GAPuB,EAWjC,CAXM,CAWJ,EAXI,CAYR,CA3JH,8EA6J8C,CAC1C,GAAI,GAAY,EAAhB,CAMA,WAHE,EAAY,IAAMmB,KAAKC,SAAL,GAGpB,EAAO,GACR,CArKH,wDAwK6C,CACzC,GAAK,kCAAiBrB,OAAlB,EAA8B,kCAAiBY,MAAnD,EAIM,IAAS1C,QAAOkB,WAAP,CAAmBwB,MAJlC,GAKE,EAAQ,KAAKhC,cAAL,EALV,EAOM,IAAOV,QAAOkB,WAAP,CAAmBwB,MAPhC,GAQE,EAAM,KAAKhC,cAAL,EARR,EAWA,GAAI,CACF,KAAKX,OAAL,CAAamB,WAAb,CAAyBY,OAAzB,CAAiC,KAAKpB,cAAL,CAAsB,KAAK0C,wBAAL,KAAvD,KAID,CAAC,QAAU,CACVC,QAAQC,KAAR,GACD,CAlBD,CAmBD,CA5LH,oDAiMgC,CAC5B,GAAK,kCAAiBxB,OAAlB,EAA8B,kCAAiBD,IAAnD,GAIA,KAAK9B,OAAL,CAAamB,WAAb,CAAyBW,IAAzB,CAA8B,KAAKnB,cAAL,EAA9B,CAJA,EAMI,CAAC,KAAKL,YAAL,GANL,8BAUA,YAAiC,KAAKA,YAAL,GAAjC,gDAA+D,mBAArDkD,IAAqD,KAA/CC,MAA+C,KAAvCC,IAAuC,CAC7D,GAAI,IAAS,CAAC,KAAKC,cAAL,GAAd,CAA2C,CAKzC,OAHE,KAAKA,cAAL,MAGF,EAAkB,mBAAd,MAA8C,4BAAT,IAAzC,CAEE,WADA,MAAKhB,MAAL,CAAY,kBAAZ,CAAgC,KAAK3C,OAAL,CAAamB,WAAb,CAAyByC,GAAzB,GAAiC,KAAK5D,OAAL,CAAamB,WAAb,CAAyBwB,MAAzB,CAAgCC,0BAAjG,CACA,CAGF,KAAKiB,WAAL,SACD,CACF,CAvBD,+EAwBD,CA1NH,8CA4NsD,2HAClD,KAAKpB,WAAL,CAAiB,KAAKP,UAAL,CAAgBL,SAAjC,GAAwD,CAAxD,KACD,CA9NH,gDAgO6D,2HACzD,KAAKY,WAAL,CAAiB,KAAKP,UAAL,CAAgB4B,SAAjC,SACD,CAlOH,0CAoO0D,2HACtD,KAAKrB,WAAL,CAAiB,KAAKP,UAAL,CAAgBS,MAAjC,SACD,CAtOH,8DA2O4B,CAExB,GAAK,KAAKjC,SAAL,CAAeqD,IAAf,CAAoB,EAAMC,IAA1B,CAAD,GAAoC,KAAKvD,SAAL,CAAesD,IAAf,CAAoB,EAAMC,IAA1B,CAAxC,CAIA,GAAwB,UAApB,KAAM1C,SAAV,CAG8B,gBAAxB,KAAM2C,aAAN,EACF,KAAKC,WAAL,CAAiBC,QAAjB,CAA0B,EAAMH,IAAhC,CAJJ,CAKI,KAAKI,eAAL,GALJ,CAOI,KAAKzB,MAAL,CAAY,gBAAZ,CAA8B,EAAM0B,QAApC,CAA8C,CAC5CC,IAAK,EAAMN,IADiC,CAE5CC,cAAe,EAAMA,aAFuB,CAG5CM,OAAqC,CAA1B,KAAMC,eAAN,EAAsD,CAAvB,KAAMC,YAHJ,CAA9C,CAPJ,KAaO,IAAwB,SAApB,KAAMnD,SAAV,CAAmC,OACrB,EAAM0C,IAAN,CAAWU,KAAX,CAAiB,GAAjB,CAAsB,CAAtB,CADqB,qCAExC,EAAO,EAAKA,KAAL,CAAW,KAAK/D,cAAhB,CAAgC,CAAhC,EAAmCgE,GAAnC,EAFiC,KAItC,EAAOxB,KAAKyB,KAAL,GAJ+B,EAMxC,KAAKjC,MAAL,GAAkB,EAAM0B,QAAxB,GACD,CACF,CAtQH,iDAwQuG,8DAAjF,mBAAiF,0DAAtD,kBAAsD,4IAC/F,CAAC,KAAK7C,MAAL,CAAYqD,OAAb,EAAwB,KAAK7E,OAAL,CAAa8E,SAAb,CAAuBC,UADgD,IAKvF,CAAR,OAL+F,CAU/F,IAAS,KAAK7C,UAAL,CAAgBS,MAAzB,GAAoC,CAAC,KAAK3C,OAAL,CAAagF,QAAb,GAAD,EAA+B,OAA/B,EAAqD,CAAN,EAAnF,CAV+F,KAWjG,MAAKnD,SAAL,CAAe,eAAf,CAXiG,MAenG,KAAKiB,KAAL,CAAWR,IAAX,CAAgB,CAAC2C,MAAD,CAAOC,KAAP,CAAYC,KAAZ,CAAiBC,MAAjB,CAAhB,CAfmG,GAkBjG,KAAKC,YAAL,EAlBiG,CAmBxF,CAAC,KAAKtC,YAnBkF,GAsBjG,KAAKA,YAAL,CAAoB,KAAK/C,OAAL,CAAaG,UAAb,CAClB,KAAKkF,YAAL,CAAkB7C,IAAlB,CAAuB,IAAvB,CADkB,CAElB,KAAKhB,MAAL,CAAY8D,OAAZ,KAFkB,CAtB6E,SA2BpG,CAnSH,gDAsSoB,CAChB,GAAM,KAAN,CACA,IAAK,GAAI,EAAT,MACE,EAAQhD,IAAR,OAA2B,KAAKiD,YAAL,CAAkB,IAAlB,CAA3B,EAGF,QACD,CA7SH,gDA+SiC,CAK7B,MAJK,KAIL,GAHE,KAAqB,EAAWC,EAAX,EAGvB,EAAO,IACR,CArTH,sDAuToC,aACZ,CAAhB,KAAOP,IAAP,EAAqC,CAAhB,KAAOA,IAA5B,EAA0D,CAAhB,KAAOA,IADrB,IAE9B,EAAOE,GAFuB,EAEJ,CAFI,EAIhC,EAAOC,IAAP,CAAc,KAAKK,UAAL,CAAgB,EAAOL,IAAvB,CAJkB,CAKhC,EAAOF,GAAP,CAAa,KAAKQ,UAAL,CAAgB,EAAOR,GAAvB,CALmB,CAQhC,EAAOA,GAAP,CAAa,KAAKS,SAAL,CAAe,EAAOT,GAAtB,GARmB,CAShC,EAAOE,IAAP,CAAc,EAAOA,IAAP,CAAYQ,GAAZ,CAAgB,kBAAU,GAAKD,SAAL,KAAV,CAAhB,CATkB,CAWN,QAAtB,QAAO,GAAOR,GAXc,GAY9B,EAAOA,GAAP,CAAa,KAAKQ,SAAL,CAAe,EAAOR,GAAtB,GAZiB,CAcjC,CArUH,wDAuUyB,CACrB,GAAM,GAAU,CACd,QAAW,KAAK5E,YADF,CAEd,UAAa,KAAKF,UAAL,CAAgBwF,KAAhB,EAFC,CAGd,UAHc,CAAhB,CAMM,IANN,CAOAC,OAAOC,cAAP,GAAkC,IAAlC,CAAwC,CACtCC,MAAO,CAD+B,CAEtCC,WAFsC,CAGtCC,eAHsC,CAItCC,aAJsC,CAAxC,CARqB,CAgBrB,GAAM,kKAAN,oBAhBqB,IA2BrB,yEAGE,KAAKC,YAAL,KAHF,CAKE,EAAQC,OAAR,CAAgB/D,IAAhB,kBACEgE,IAAK,EAAOlB,IADd,CAEEH,KAAM,EAAOA,IAFf,CAGEsB,WAAY,EAAOrB,GAHrB,EAIG,EAAY,EAAOD,IAAnB,CAJH,CAI8B,EAAOE,GAJrC,EAhCmB,8EAyCrB,EAAQqB,UAAR,CAAqB/G,iBAzCA,CA0CrB6D,QAAQmD,GAAR,CAAY,EAAQD,UAApB,CA1CqB,CA2CrBlD,QAAQmD,GAAR,GA3CqB,CA6CrB,GAAM,GAAQ9G,eAAe+G,MAAf,GAAd,CA7CqB,aA+CnBpD,SAAQC,KAAR,GA/CmB,CAmDd5D,eAAegH,MAAf,CAAsBhH,eAAeiH,MAAf,GAAtB,EAAsDC,MAAtD,EACR,CA3XH,mDA6XkB,CAGd,GAAM,GAAO,GAAI,MAAKzG,cAAtB,CACA,EAAK0G,IAAL,CAAU,KAAV,CAAiB,mCAAjB,CAJc,CAKd,EAAKC,gBAAL,CAAsB,cAAtB,CAAsC,0BAAtC,CALc,CAMd,GAAM,GAAU,KAAKC,cAAL,CAAoB,KAAKlE,KAAzB,CAAhB,CANc,GAQZ,EAAKmE,IAAL,GARY,CAWd,KAAKpG,UAAL,EACD,CAzYH,S,gBAOqBd,S","file":"service.js","sourcesContent":["/* eslint-disable no-return-assign */\nimport protobuf from 'protobufjs/light'\nimport jsonProtobufDescriptor from './metrics.json'\nimport featureAvailable from './feature-detection-service.js'\n\nfunction invertObjectKV (json) {\n  const flipped = {}\n  for (let key in json) {\n    flipped[json[key]] = key\n  }\n  return flipped\n}\n\n// metric is the name of the range, the key is the end marker\n// from is the start of the range\n// an end marker can have more than one metric/start\n// const TIMING_RANGES = {\n  // 'page.digested': [\n    // {\n      // from: 'page.resolved',\n      // metric: 'ui.digested'\n    // },\n    // {\n      // from: 'navigationStart',\n      // metric: 'ui.timeToFirstDigest',\n      // once: true\n    // }\n  // ]\n// }\n\nfunction isDefined (value) {\n  return typeof value !== 'undefined'\n}\n\nlet metricsMessage = protobuf.Root.fromJSON(jsonProtobufDescriptor).lookupType('fsMetrics.fsMetricsMessage')\n\n// pass in global tags\n// pass in normalization tags\n// pass in ignored urls\n// pass in whiteList of resources\n\nexport default class fsMetrics {\n  constructor ({\n    $window = window,\n    $timeout = window.setTimeout,\n    XMLHttpRequest = window.XMLHttpRequest,\n    globalTags,\n    timingRanges,\n    codeRevision,\n    stringReplace,\n    blackList,\n    whiteList,\n    timelinePrefix\n  } = {}\n  ) {\n    this.$window = $window\n    this.$timeout = $timeout\n    this.XMLHttpRequest = XMLHttpRequest\n\n    this.globalTags = globalTags || [] // tags that will be applied to all metrics\n    this.timingRanges = timingRanges\n    this.codeRevision = codeRevision\n    this.stringReplace = stringReplace\n    this.blackList = blackList\n    this.whiteList = whiteList\n    this.timelinePrefix = timelinePrefix\n\n    this.loadFired = false\n\n    this.resetQueue()\n    this.buildServerSharedDictionary()\n\n    this.trackUnsupportedFeatures()\n\n    this.upgradeQueue()\n    this.trackExistingPerformanceEntries()\n  }\n\n  trackExistingPerformanceEntries () {\n    if (!featureAvailable.performanceTimeline) {\n      return\n    }\n    this.$window.performance.getEntries().forEach(entry => {\n      if (entry.entryType === 'measure' || entry.entryType === 'resource') {\n        this.performanceTiming(entry)\n      }\n    })\n    this.config.timeParse !== 'true' && this.$window.performance.clearMeasures()\n    featureAvailable.clearResourceTimings && this.$window.performance.clearResourceTimings()\n  }\n\n  trackUnsupportedFeatures () {\n    if (!featureAvailable.navigationTiming) {\n      this.increment('timingUnsupported')\n    }\n\n    if (!featureAvailable.mark) {\n      this.increment('markUnsupported')\n    }\n\n    if (!featureAvailable.measure) {\n      this.increment('markUnsupported')\n    }\n\n    if (!featureAvailable.performanceTimeline) {\n      this.increment('resourceTimingUnsupported')\n    }\n  }\n\n  buildServerSharedDictionary (metricNames, metricTags, eventTypes) {\n    this.metricNames = {}\n    this.metricTags = {}\n    this.eventTypes = {}\n\n    if (metricNames) {\n      this.config.metricNames.forEach((v, i) => this.metricNames[v] = i)\n    }\n    if (metricTags) {\n      this.config.metricTags.forEach((v, i) => this.metricTags[v] = '' + i)\n    }\n    if (eventTypes) {\n      this.config.eventTypes.forEach((v, i) => this.eventTypes[v] = i)\n    }\n  }\n\n  /*\n   * Allows you to record metrics before datadog is available\n   * Turns raw array into direct call to queueMetric\n   * This way we can queue up metrics before this lib is loaded\n   */\n  upgradeQueue () {\n    if (this.$window.fsMetrics &&\n      Array.isArray(this.$window.fsMetrics) &&\n      Array.prototype.push === this.$window.fsMetrics.push) {\n      this.$window.fsMetrics.push = this.convertWindowQueue.bind(this)\n      this.$window.fsMetrics.forEach(this.$window.fsMetrics.push)\n    }\n  }\n\n  convertWindowQueue ([type, key, val = 1, tags = {}, andFlush = false]) {\n    if (type === 'pageload') {\n      tags.dest = key\n      if (featureAvailable.navigationTiming) {\n        var domTiming = window.performance.timing.domContentLoadedEventStart - window.performance.timing.navigationStart\n        if (domTiming < 120000) {\n          this.timing('domContentLoaded', domTiming, tags, true)\n        } else {\n          this.increment('timingOutlier', tags, true)\n        }\n      } else {\n        this.increment('timingUnsupported', tags, true)\n      }\n    } else {\n      if (typeof type === 'string') {\n        type = this.eventTypes[type]\n      }\n\n      this.queueMetric(type, key, val, tags, andFlush)\n    }\n  }\n\n  resetQueue () {\n    this.queue = []\n    if (this.activeBuffer) {\n      this.$window.clearTimeout(this.activeBuffer)\n    }\n    this.activeBuffer = false\n  }\n\n  normalizeTag (tag) {\n    tag += ''\n\n    return this.stringReplace.reduce((tag, [search, replace]) => tag.replace(search, replace), tag)\n  }\n\n  // turns metricnames into smaller form\n  encodeStat (...stats) {\n    return stats.reduce((iv, stat) => {\n      if (stat) { // && angular.isUndefined(this.metricNames[stat])) {\n      // if (stat && !isDefined(this.metricNames[stat])) {\n        stat += ''\n        return iv + stat\n        .replace(/[^\\w:.-]+/g, '_') // turn statsc illegal chars into _\n      } else if (stat && isDefined(this.metricNames[stat])) {\n        return this.metricNames[stat]\n      } else {\n        return iv\n      }\n    }, '')\n  }\n\n  encodeTagsIntoMetricName (metricName, tags) {\n    let tagstring = ''\n\n    if (tags) {\n      tagstring = '|' + JSON.stringify(tags)\n    }\n\n    return metricName + tagstring\n  }\n\n  // some metric names are reserved\n  measureSafe (metricName, start, end, tags) {\n    if (!featureAvailable.measure || !featureAvailable.timing) {\n      return\n    }\n\n    if (!(start in window.performance.timing)) {\n      start = this.timelinePrefix + start\n    }\n    if (!(end in window.performance.timing)) {\n      end = this.timelinePrefix + end\n    }\n\n    try {\n      this.$window.performance.measure(this.timelinePrefix + this.encodeTagsIntoMetricName(metricName, tags),\n        start,\n        end\n      )\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  /**\n   * mark the current point and create a measure\n   */\n  timingEvent (eventName, tags) {\n    if (!featureAvailable.measure || !featureAvailable.mark) {\n      return\n    }\n\n    this.$window.performance.mark(this.timelinePrefix + eventName)\n\n    if (!this.timingRanges[eventName]) {\n      return\n    }\n\n    for (let {from, metric, once} of this.timingRanges[eventName]) {\n      if (!once || !this.oneTimeMetrics[metric]) {\n        if (once) {\n          this.oneTimeMetrics[metric] = true\n        }\n\n        if (eventName === 'stateChange.start' && from === 'domContentLoadedEventStart') {\n          this.timing('timeToFirstRoute', this.$window.performance.now() - this.$window.performance.timing.domContentLoadedEventStart)\n          return\n        }\n\n        this.measureSafe(metric, from, eventName, tags)\n      }\n    }\n  }\n\n  increment (metricName, tags = {}, andFlush = false) {\n    this.queueMetric(this.eventTypes.increment, metricName, 1, tags, andFlush)\n  }\n\n  histogram (metricName, value, tags = {}, andFlush = false) {\n    this.queueMetric(this.eventTypes.histogram, metricName, value, tags, andFlush)\n  }\n\n  timing (metricName, value, tags = {}, andFlush = false) {\n    this.queueMetric(this.eventTypes.timing, metricName, value, tags, andFlush)\n  }\n\n  /*\n   * given a PerformanceEntry log to datadog a measure or resource\n   */\n  performanceTiming (entry) {\n    // only send whitelisted urls, ignore blacklisted\n    if (!this.whiteList.test(entry.name) || this.blackList.test(entry.name)) {\n      return\n    }\n\n    if (entry.entryType === 'resource') {\n      // this section is entirely for determining if a license request is OPTIONS\n      // or the actual request\n      if (entry.initiatorType === 'xmlhttprequest' &&\n        this.licenceUrls.includes(entry.name)) {\n        this.trackLicenseReq(entry)\n      } else {\n        this.timing('resourceTiming', entry.duration, {\n          url: entry.name,\n          initiatorType: entry.initiatorType,\n          cached: !!(entry.decodedBodySize !== 0 && entry.transferSize === 0)\n        })\n      }\n    } else if (entry.entryType === 'measure') {\n      let [name, tags] = entry.name.split('|', 2)\n      name = name.split(this.timelinePrefix, 2).pop()\n      if (tags) {\n        tags = JSON.parse(tags)\n      }\n      this.timing(name, entry.duration, tags)\n    }\n  }\n\n  queueMetric (type = 'type is undefined', key = 'key is undefined', val, tags = {}, andFlush = false) {\n    if (!this.config.enabled || this.$window.navigator.doNotTrack) {\n      return false\n    }\n\n    if (val !== 0 && !val) {\n      return\n    }\n\n    // log timings over 2 minutes, they're probably outliers or errors\n    if (type === this.eventTypes.timing && (!this.$window.isFinite(val) || val > 120000 || val < 0)) {\n      this.increment('timingOutlier')\n      return\n    }\n\n    this.queue.push({type, key, val, tags})\n\n    if (andFlush) {\n      this.flushMetrics()\n    } else if (!this.activeBuffer) {\n      // Using setTimeout instead of $timeout here as $timeout blocks\n      // Protractor tests from running\n      this.activeBuffer = this.$window.setTimeout(\n        this.flushMetrics.bind(this),\n        this.config.bufTime || 5000\n      )\n    }\n  }\n\n  // collapses object to array of tagname:tagval + converts that tag to simple form\n  encodeTags (tags) {\n    const encoded = []\n    for (let tagName in tags) {\n      encoded.push(`${tagName}:${this.normalizeTag(tags[tagName])}`)\n    }\n\n    return encoded\n  }\n\n  buildDict (string, stringDict) {\n    if (!stringDict[string]) {\n      stringDict[string] = stringDict.id++\n    }\n\n    return stringDict[string]\n  }\n\n  encodeMetric (metric, stringDict) {\n    if (metric.type === 0 || metric.type === 3 || metric.type === 5) {\n      metric.val = metric.val | 0\n    }\n    metric.tags = this.encodeTags(metric.tags)\n    metric.key = this.encodeStat(metric.key)\n\n    // turn strings into numbers and send the dictionary along\n    metric.key = this.buildDict(metric.key, stringDict)\n    metric.tags = metric.tags.map(string => this.buildDict(string, stringDict))\n\n    if (typeof metric.val === 'string') {\n      metric.val = this.buildDict(metric.val, stringDict)\n    }\n  }\n\n  preparePayload (queue) {\n    const msgJSON = {\n      'codeSha': this.codeRevision,\n      'globalTag': this.globalTags.slice(),\n      'aMetric': []\n    }\n\n    const stringDict = {}\n    Object.defineProperty(stringDict, 'id', {\n      value: 0,\n      writable: true,\n      configurable: false,\n      enumerable: false\n    })\n\n    // TODO figure out how to get the lib to do this conversion for us\n    const MetricValue = {\n      0: 'metricValueTiming',\n      1: 'metricValueSet',\n      2: 'metricValueGuage',\n      3: 'metricValueIncrement',\n      4: 'metricValueHistogram',\n      5: 'metricValueIncrement',\n      6: 'metricValueEvent'\n    }\n    // type key val tags\n    // type name tag value\n    for (let metric of queue) {\n      // encodeTags\n      // encodeStat\n      this.encodeMetric(metric, stringDict)\n\n      msgJSON.aMetric.push({\n        tag: metric.tags,\n        type: metric.type,\n        metricName: metric.key,\n        [MetricValue[metric.type]]: metric.val\n      })\n    }\n\n    // flip keys and values\n    msgJSON.stringDict = invertObjectKV(stringDict)\n    console.log(msgJSON.stringDict)\n    console.log(msgJSON)\n\n    const error = metricsMessage.verify(msgJSON)\n    if (error) {\n      console.error(error)\n      return\n    }\n\n    return metricsMessage.encode(metricsMessage.create(msgJSON)).finish()\n  }\n\n  flushMetrics () {\n    // since we aren't using $http we have to use other means to get the request\n    // to not be made while running tests\n    const oreq = new this.XMLHttpRequest()\n    oreq.open('PUT', 'http://localhost:3003/api/metrics')\n    oreq.setRequestHeader('Content-Type', 'application/octet-stream')\n    const payload = this.preparePayload(this.queue)\n    if (payload) {\n      oreq.send(payload)\n    }\n\n    this.resetQueue()\n  }\n}\n"]}